{"version":3,"file":"getStateFromPath.js","sourceRoot":"","sources":["../../src/fork/getStateFromPath.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qDAA6E;AAE7E,gFAA0C;AAE1C,yDAAsD;AACtD,gEAAkD;AAGlD,0CAAyE;AAiDzE;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,SAAgB,gBAAgB;AAG9B,WAAW;AACX,IAAY,EACZ,OAA4B;IAE5B,IAAI,OAAO,EAAE;QACX,IAAA,2BAAkB,EAAC,OAAO,CAAC,CAAC;KAC7B;IAED,MAAM,WAAW,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;IAEzC,IAAI,CAAC,WAAW,EAAE;QAChB,OAAO;KACR;IAED,MAAM,aAAa,GAAyB,EAAE,CAAC;IAE/C,IAAI,OAAO,EAAE,gBAAgB,EAAE;QAC7B,aAAa,CAAC,IAAI,CAAC;YACjB,gBAAgB,EAAE,OAAO,CAAC,gBAAgB;YAC1C,aAAa,EAAE,EAAE;SAClB,CAAC,CAAC;KACJ;IAED,MAAM,OAAO,GAAG,OAAO,EAAE,OAAO,CAAC;IAEjC,IAAI,SAAS,GAAG,WAAW,EAAE,mBAAmB;SAC7C,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,+CAA+C;SACpE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,6BAA6B;SAChD,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC,iDAAiD;IAE1E,sCAAsC;IACtC,SAAS,GAAG,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,SAAS,GAAG,CAAC;IAElE,MAAM,MAAM,GAAG,OAAO,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,6BAA6B;IAE/E,IAAI,MAAM,EAAE;QACV,sCAAsC;QACtC,MAAM,gBAAgB,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,GAAG,CAAC;QAEtE,8DAA8D;QAC9D,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,gBAAgB,CAAC,EAAE;YAC3C,OAAO,SAAS,CAAC;SAClB;QAED,kCAAkC;QAClC,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,gBAAgB,EAAE,EAAE,CAAC,CAAC;KACrD;IAED,IAAI,OAAO,KAAK,SAAS,EAAE;QACzB,oEAAoE;QACpE,MAAM,MAAM,GAAG,SAAS;aACrB,KAAK,CAAC,GAAG,CAAC;aACV,MAAM,CAAC,OAAO,CAAC;aACf,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;YACf,MAAM,IAAI,GAAG,kBAAkB,CAAC,OAAO,CAAC,CAAC;YACzC,OAAO,EAAE,IAAI,EAAE,CAAC;QAClB,CAAC,CAAC,CAAC;QAEL,IAAI,MAAM,CAAC,MAAM,EAAE;YACjB,OAAO,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE,aAAa,EAAE,SAAS,EAAE,WAAW,CAAC,IAAI,CAAC,CAAC;SAC1F;QAED,OAAO,SAAS,CAAC;KAClB;IAED,gEAAgE;IAChE,MAAM,OAAO,GAAI,EAAoB;SAClC,MAAM,CACL,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAClC,uBAAuB,CAAC,GAAG,EAAE,OAAgC,EAAE,EAAE,EAAE,aAAa,EAAE,EAAE,CAAC,CACtF,CACF;SACA,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;IACrD,WAAW;IAEX,6CAA6C;IAC7C,OAAO,CAAC,MAAM,CAA8B,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE;QAC1D,IAAI,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;YACvB,MAAM,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC;YACzC,MAAM,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC;YAE5B,yEAAyE;YACzE,oEAAoE;YACpE,MAAM,UAAU,GACd,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;YAE1F,IAAI,CAAC,UAAU,EAAE;gBACf,MAAM,IAAI,KAAK,CACb,iEACE,MAAM,CAAC,OACT,uBAAuB,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,IAAI,CAClD,KAAK,CACN,wEAAwE,CAC1E,CAAC;aACH;SACF;QAED,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE;YACxB,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,MAAM;SACzB,CAAC,CAAC;IACL,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,IAAI,SAAS,KAAK,GAAG,EAAE;QACrB,uFAAuF;QACvF,yEAAyE;QACzE,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CACxB,CAAC,MAAM,EAAE,EAAE,CACT,MAAM,CAAC,IAAI,KAAK,EAAE;YAClB,MAAM,CAAC,UAAU,CAAC,KAAK;YACrB,0EAA0E;YAC1E,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,IAAI,CAAC,EAAE,IAAI,CACxD,CACJ,CAAC;QAEF,IAAI,KAAK,EAAE;YACT,OAAO,uBAAuB,CAC5B,WAAW,CAAC,SAAS,EACrB,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,EAC1C,aAAa,EACb,OAAO,EACP,WAAW,CAAC,IAAI,CACjB,CAAC;SACH;QAED,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,MAAiD,CAAC;IACtD,IAAI,OAAkD,CAAC;IAEvD,gEAAgE;IAChE,2FAA2F;IAC3F,MAAM,EAAE,MAAM,EAAE,aAAa,EAAE,GAAG,mBAAmB,CACnD,SAAS;IACT,aAAa;IACb,sDAAsD;IACtD,wBAAwB;IACxB,UAAU;IACV,gGAAgG;IAChG,mEAAmE;IACnE,MAAM;IACN,OAAO;IACP,WAAW;KACZ,CAAC;IAEF,IAAI,MAAM,KAAK,SAAS,EAAE;QACxB,iDAAiD;QACjD,OAAO,GAAG,uBAAuB,CAC/B,WAAW,CAAC,SAAS,EACrB,MAAM,EACN,aAAa,EACb,OAAO,EACP,WAAW,CAAC,IAAI,CACjB,CAAC;QACF,SAAS,GAAG,aAAa,CAAC;QAC1B,MAAM,GAAG,OAAO,CAAC;KAClB;IAED,IAAI,OAAO,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE;QACrC,OAAO,SAAS,CAAC;KAClB;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAtKD,4CAsKC;AAED,MAAM,SAAS,GAAG,CAAC,GAAG,KAAe,EAAU,EAAE,CAC9C,EAAe;KACb,MAAM,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;KACzC,MAAM,CAAC,OAAO,CAAC;KACf,IAAI,CAAC,GAAG,CAAC,CAAC;AAEf,MAAM,mBAAmB,GAAG,CAAC,SAAiB,EAAE,OAAsB,EAAE,EAAE;IACxE,IAAI,MAAiC,CAAC;IACtC,IAAI,aAAa,GAAG,SAAS,CAAC;IAE9B,6EAA6E;IAC7E,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;QAC5B,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE;YACjB,SAAS;SACV;QAED,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEhD,gEAAgE;QAChE,IAAI,KAAK,EAAE;YACT,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAInD,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE;gBAChB,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;oBACtB,OAAO,GAAG,CAAC;iBACZ;gBAED,uDAAuD;gBACvD,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;gBAEb,aAAa;gBACb,6EAA6E;gBAC7E,IAAI,CAAC,KAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;oBAAE,OAAO,GAAG,CAAC;gBAC3C,WAAW;gBAEX,MAAM,mBAAmB,GAAG,kBAAkB;gBAC5C,wFAAwF;gBACxF,KAAM,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;oBACvB,wBAAwB;qBACvB,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CACtB,CAAC;gBAEF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,EAAE;oBAC/B,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE;wBAC7C,CAAC,KAAK,CAAC,EAAE,mBAAmB;qBAC7B,CAAC;iBACH,CAAC,CAAC;gBAEH,OAAO,GAAG,CAAC;YACb,CAAC,EACD,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,aAAa,EAAE,EAAE,EAAE,CAC/B,CAAC;YAEF,MAAM,aAAa,GAAG,WAAW,CAAC,aAAa,IAAI,EAAE,CAAC;YAEtD,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;gBACtC,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE;oBACrC,4FAA4F;oBAC5F,OAAO,CAAC,CAAC,MAAM,KAAK,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;gBACnE,CAAC,CAAC,CAAC;gBAEH,oFAAoF;gBACpF,MAAM,cAAc,GAAG,WAAW,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAE9E,oDAAoD;gBACpD,MAAM,kBAAkB,GAAG,WAAW,EAAE,OAAO;oBAC7C,yIAAyI;qBACxI,OAAO,CAAC,IAAI,MAAM,CAAC,GAAG,IAAA,8BAAM,EAAC,cAAe,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;oBACvD,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;gBAEtB,MAAM,MAAM,GAAG,cAAc;oBAC3B,EAAE,KAAK,CAAC,GAAG,CAAC;qBACX,MAAM,CAA0B,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE;oBACjD,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;wBACtB,OAAO,GAAG,CAAC;qBACZ;oBAED,+DAA+D;oBAC/D,iEAAiE;oBACjE,MAAM,MAAM,GAAG,kBAAkB,CAAC,CAAC,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC/D,MAAM,KAAK,GAAG,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;oBAEjD,IAAI,KAAK,EAAE;wBACT,MAAM,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;wBACnD,GAAG,CAAC,GAAG,CAAC,GAAG,WAAW,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;qBAC9E;oBAED,OAAO,GAAG,CAAC;gBACb,CAAC,EAAE,EAAE,CAAC,CAAC;gBAET,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE;oBACxC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;iBACzB;gBAED,OAAO,EAAE,IAAI,EAAE,CAAC;YAClB,CAAC,CAAC,CAAC;YAEH,aAAa;YACb,oFAAoF;YACpF,uHAAuH;YACvH,wGAAwG;YACxG,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YAC/E,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBACxC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;oBACvB,KAAK,CAAC,MAAM,GAAG,EAAE,GAAG,YAAY,EAAE,CAAC;gBACrC,CAAC,CAAC,CAAC;aACJ;YACD,WAAW;YAEX,aAAa,GAAG,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAEpD,MAAM;SACP;KACF;IAED,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,CAAC;AACnC,CAAC,CAAC;AAEF,MAAM,uBAAuB,GAAG,CAC9B,MAAc,EACd,WAAkC,EAClC,aAAuB,EAAE,EACzB,QAA8B,EAC9B,aAAuB,EACvB,aAAsB,EACP,EAAE;IACjB,MAAM,OAAO,GAAkB,EAAE,CAAC;IAElC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAExB,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAE3B,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;IAEnC,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;QAC9B,6FAA6F;QAC7F,MAAM,OAAO,GAAG,aAAa,CAAC,CAAC,CAAC,SAAS,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAE1E,OAAO,CAAC,IAAI,CACV,gBAAgB,CACd,MAAM,EACN,UAAU,EACV,OAAO,EACP,MAAM;QACN,aAAa;QACb,SAAS,EACT,KAAK;QACL,WAAW;SACZ,CACF,CAAC;KACH;SAAM,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;QACrC,IAAI,OAA2B,CAAC;QAEhC,8DAA8D;QAC9D,kCAAkC;QAClC,wDAAwD;QACxD,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,EAAE;YACnC,IAAI,MAAM,CAAC,KAAK,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,EAAE;gBAC7C,MAAM,IAAI,KAAK,CACb,sJAAsJ,CACvJ,CAAC;aACH;YAED,OAAO;gBACL,MAAM,CAAC,KAAK,KAAK,IAAI;oBACnB,CAAC,CAAC,SAAS,CAAC,aAAa,IAAI,EAAE,EAAE,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC;oBACnD,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC;YAExB,OAAO,CAAC,IAAI,CACV,gBAAgB,CACd,MAAM,EACN,UAAU,EACV,OAAQ,EACR,MAAM,CAAC,IAAI,EACX,MAAM,CAAC,KAAK;YACZ,aAAa;YACb,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,KAAK,EAC9D,MAAM,CAAC,MAAM;YACb,WAAW;aACZ,CACF,CAAC;SACH;QAED,IAAI,MAAM,CAAC,OAAO,EAAE;YAClB,+DAA+D;YAC/D,IAAI,MAAM,CAAC,gBAAgB,EAAE;gBAC3B,QAAQ,CAAC,IAAI,CAAC;oBACZ,gBAAgB,EAAE,MAAM,CAAC,gBAAgB;oBACzC,aAAa;iBACd,CAAC,CAAC;aACJ;YAED,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;gBACnD,MAAM,MAAM,GAAG,uBAAuB,CACpC,YAAY,EACZ,MAAM,CAAC,OAAgC,EACvC,UAAU,EACV,QAAQ,EACR,CAAC,GAAG,aAAa,CAAC,EAClB,OAAO,IAAI,aAAa,CACzB,CAAC;gBAEF,OAAO,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC;YAC1B,CAAC,CAAC,CAAC;SACJ;KACF;IAED,UAAU,CAAC,GAAG,EAAE,CAAC;IAEjB,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF,MAAM,gBAAgB,GAAG,CACvB,MAAc,EACd,UAAoB,EACpB,OAAe,EACf,IAAY,EACZ,KAAmB;AACnB,aAAa;AACb,WAAqB,EACrB,MAAY;AACZ,WAAW;EACE,EAAE;IACf,oFAAoF;IACpF,MAAM,YAAY,GAAa,EAAE,CAAC;IAClC,MAAM,KAAK,GAAa,EAAE,CAAC;IAC3B,IAAI,SAAS,GAAG,KAAK,CAAC;IACtB,MAAM,OAAO,GAAG,MAAM,KAAK,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAEhE,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;QACrC,IAAI,IAAI,EAAE;YACR,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAExB,oDAAoD;YACpD,SAAS,KAAK,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAE1F,IAAI,CAAC,IAAA,yBAAc,EAAC,IAAI,CAAC,EAAE;gBACzB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAClB;SACF;KACF;IAED,OAAO,GAAG,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEjC,IAAI,OAAO,EAAE;QACX,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KACrB;IAED,MAAM,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC;IAEvE,MAAM,KAAK,GAAG,OAAO;QACnB,CAAC,CAAC,IAAI,MAAM,CAAC,KAAK,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC;QAC1E,CAAC,CAAC,SAAS,CAAC;IAEd,OAAO;QACL,MAAM;QACN,KAAK;QACL,OAAO;QACP,IAAI;QACJ,wEAAwE;QACxE,UAAU,EAAE,CAAC,GAAG,UAAU,CAAC;QAC3B,KAAK;QACL,aAAa;QACb,IAAI;QACJ,KAAK;QACL,kBAAkB,EAAE,UAAU,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAC9C,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACzB,CAAC,CAAC;QACF,gBAAgB,EAAE,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,IAAI,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;QACxE,WAAW,EAAE,CAAC,CAAC,WAAW;QAC1B,OAAO;QACP,MAAM;QACN,WAAW;KACZ,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,uBAAuB,GAAG,CAC9B,SAAiB,EACjB,UAAyB,EACA,EAAE;IAC3B,KAAK,MAAM,MAAM,IAAI,UAAU,EAAE;QAC/B,IAAI,SAAS,KAAK,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;YACjE,OAAO,MAAM,CAAC,KAAK,CAAC;SACrB;KACF;IAED,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,6DAA6D;AAC7D,MAAM,gBAAgB,GAAG,CACvB,SAAiB,EACjB,aAAuB,EACvB,aAAmC,EACf,EAAE;IACtB,KAAK,MAAM,MAAM,IAAI,aAAa,EAAE;QAClC,IAAI,aAAa,CAAC,MAAM,KAAK,MAAM,CAAC,aAAa,CAAC,MAAM,EAAE;YACxD,IAAI,WAAW,GAAG,IAAI,CAAC;YACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC7C,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;oBACjE,WAAW,GAAG,KAAK,CAAC;oBACpB,MAAM;iBACP;aACF;YACD,IAAI,WAAW,EAAE;gBACf,OAAO,SAAS,KAAK,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,SAAS,CAAC;aACpF;SACF;KACF;IACD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,wDAAwD;AACxD,qEAAqE;AACrE,MAAM,iBAAiB,GAAG,CACxB,YAAgC,EAChC,KAAkB,EAClB,OAAgB,EACF,EAAE;IAChB,IAAI,OAAO,EAAE;QACX,IAAI,YAAY,EAAE;YAChB,OAAO;gBACL,KAAK,EAAE,CAAC;gBACR,aAAa;gBACb,2CAA2C;gBAC3C,MAAM,EAAE,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC;gBAC7D,WAAW;aACZ,CAAC;SACH;aAAM;YACL,OAAO;gBACL,MAAM,EAAE,CAAC,KAAK,CAAC;aAChB,CAAC;SACH;KACF;SAAM;QACL,IAAI,YAAY,EAAE;YAChB,OAAO;gBACL,KAAK,EAAE,CAAC;gBACR,MAAM,EAAE;oBACN,aAAa;oBACb,0BAA0B;oBAC1B,EAAE,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE;oBAC5C,WAAW;oBACX,EAAE,GAAG,KAAK,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE;iBACpC;aACF,CAAC;SACH;aAAM;YACL,OAAO;gBACL,MAAM,EAAE,CAAC,EAAE,GAAG,KAAK,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC;aAC9C,CAAC;SACH;KACF;AACH,CAAC,CAAC;AAEF,MAAM,uBAAuB,GAAG,CAC9B,IAAY,EACZ,MAAqB,EACrB,aAAmC,EACnC,UAA0B;AAC1B,aAAa;AACb,IAAa;AACb,WAAW;EACX,EAAE;IACF,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,EAAiB,CAAC;IAC1C,MAAM,aAAa,GAAa,EAAE,CAAC;IAEnC,IAAI,YAAY,GAAG,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;IAE9E,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAE/B,MAAM,KAAK,GAAiB,iBAAiB,CAAC,YAAY,EAAE,KAAK,EAAE,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;IAExF,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACrB,IAAI,WAAW,GAAG,KAAK,CAAC;QAExB,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,EAAiB,CAAC,EAAE;YAC9C,YAAY,GAAG,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,aAAa,EAAE,aAAa,CAAC,CAAC;YAE1E,MAAM,gBAAgB,GAAG,WAAW,CAAC,KAAK,IAAI,WAAW,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;YAE5E,WAAW,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,KAAK,GAAG,iBAAiB,CAC5D,YAAY,EACZ,KAAK,EACL,MAAM,CAAC,MAAM,KAAK,CAAC,CACpB,CAAC;YAEF,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBACrB,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,KAAqB,CAAC;aAC1E;YAED,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAChC;KACF;IAED,KAAK,GAAG,IAAA,mCAAgB,EAAC,KAAK,CAAgB,CAAC;IAC/C,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;IAElB,MAAM,MAAM,GAAG,gBAAgB,CAC7B,IAAI,EACJ,UAAU,CAAC,CAAC,CAAC,uBAAuB,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,EACxE,IAAI,CACL,CAAC;IAEF,IAAI,MAAM,EAAE;QACV,aAAa;QACb,iDAAiD;QACjD,KAAK,CAAC,iBAAiB,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QACvC,WAAW;KACZ;IAED,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEF,0CAA0C;AAC1C,6BAA6B;AAC7B,kBAAkB;AAClB,yDAAyD;AACzD,SAAS;AACT,sCAAsC;AACtC,6CAA6C;AAE7C,uBAAuB;AACvB,8CAA8C;AAC9C,aAAa;AACb,2DAA2D;AAC3D,2CAA2C;AAC3C,YAAY;AACZ,oEAAoE;AACpE,UAAU;AACV,UAAU;AACV,MAAM;AAEN,4DAA4D;AAC5D,KAAK;AACL,MAAM,gBAAgB,GAAG,KAAK,CAAC,gBAAgB,CAAC;AAChD,WAAW;AAEX,aAAa;AACb,MAAM,YAAY,GAAG,IAAI,GAAG,EAAkB,CAAC;AAC/C,SAAgB,YAAY,CAC1B,IAAY,EACZ,UAA8B,OAAO,CAAC,GAAG,CAAC,aAAa;IAEvD,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,aAAa,EAAE;QAC1C,IAAI,OAAO,EAAE;YACX,MAAM,GAAG,GAAG,eAAe,CAAC,OAAO,CAAC,CAAC;YACrC,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;SACpD;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAXD,oCAWC;AAED,SAAS,eAAe,CAAC,OAAe;IACtC,IAAI,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;QAC7B,OAAO,YAAY,CAAC,GAAG,CAAC,OAAO,CAAE,CAAC;KACnC;IACD,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,QAAQ,IAAA,8BAAM,EAAC,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC;IACzD,YAAY,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACjC,OAAO,KAAK,CAAC;AACf,CAAC;AACD,WAAW;AAEX,aAAa;AACb,SAAgB,cAAc,CAC5B,IAAY,EACZ,UAA8B,OAAO,CAAC,GAAG,CAAC,aAAa;IAEvD,MAAM,OAAO,GAAG,oCAAoC,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAEpE,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE;QAChB,OAAO;KACR;IAED,IAAI,SAAS,GACX,YAAY,CAAC,IAAA,qCAA0B,EAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;IAE/F,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;QAAE,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAE1D,OAAO;QACL,SAAS;QACT,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAC/B,GAAG,OAAO;KACX,CAAC;AACJ,CAAC;AApBD,wCAoBC;AACD,WAAW;AAEX,aAAa;AACb,SAAgB,oCAAoC,CAAC,IAAY,EAAE,OAAgB;IACjF,IAAI,MAAW,CAAC;IAChB,IAAI;QACF,MAAM,GAAG,IAAI,GAAG,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;KACjD;IAAC,MAAM;QACN,gCAAgC;QAChC,OAAO;YACL,mBAAmB,EAAE,EAAE;YACvB,wBAAwB,EAAE,EAAE;YAC5B,GAAG,EAAE,IAAI;SACV,CAAC;KACH;IAED,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;IAEjC,sCAAsC;IACtC,OAAO;QACL,gDAAgD;QAChD,mBAAmB,EACjB,YAAY,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,GAAG,GAAG;QACjF,GAAG,EAAE,MAAM;KACZ,CAAC;AACJ,CAAC;AAtBD,oFAsBC;AACD,WAAW;AAEX,aAAa;AACb,SAAS,kBAAkB,CAAC,EAAU;IACpC,mCAAmC;IACnC,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAE5B,IAAI,EAAE,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;QACtB,kCAAkC;QAClC,OAAO,cAAc,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;KACrD;SAAM,IAAI,EAAE,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;QAC7B,OAAO,WAAW,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;KAClD;IAED,gCAAgC;IAChC,IAAI,IAAA,yBAAc,EAAC,EAAE,CAAC,IAAI,IAAI,EAAE;QAC9B,+BAA+B;QAC/B,sEAAsE;QACtE,+EAA+E;QAC/E,OAAO,MAAM,IAAA,8BAAM,EAAC,EAAE,CAAC,OAAO,CAAC;KAChC;IAED,OAAO,IAAA,8BAAM,EAAC,EAAE,CAAC,GAAG,KAAK,CAAC;AAC5B,CAAC;AACD,WAAW;AAEX,aAAa;AACb,SAAS,gBAAgB,CAAC,mBAA6B,EAAE;IACvD,OAAO,SAAS,WAAW,CAAC,CAAc,EAAE,CAAc;QACxD,uBAAuB;QACvB,yDAAyD;QACzD,iDAAiD;QAEjD,gEAAgE;QAChE,4EAA4E;QAC5E,IAAI,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,OAAO,EAAE;YAC3B,OAAO,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;SACrE;QAED;;;;;;;;;;;;WAYG;QACH,IAAI,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE;YACjD,OAAO,CAAC,CAAC,CAAC;SACX;QAED,IAAI,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE;YACjD,OAAO,CAAC,CAAC;SACV;QAED;;WAEG;QACH,IAAI,CAAC,CAAC,IAAI,KAAK,QAAQ,IAAI,CAAC,CAAC,IAAI,KAAK,QAAQ,EAAE;YAC9C,OAAO,CAAC,CAAC,CAAC;SACX;aAAM,IAAI,CAAC,CAAC,IAAI,KAAK,QAAQ,IAAI,CAAC,CAAC,IAAI,KAAK,QAAQ,EAAE;YACrD,OAAO,CAAC,CAAC;SACV;QAED;;WAEG;QACH,MAAM,kBAAkB,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;YAClE,OAAO,KAAK,KAAK,CAAC,CAAC,kBAAkB,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC/F,CAAC,CAAC,CAAC;QAEH,MAAM,kBAAkB,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;YAClE,OAAO,KAAK,KAAK,CAAC,CAAC,kBAAkB,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC/F,CAAC,CAAC,CAAC;QAEH,IACE,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;YAChE,kBAAkB,CAAC,MAAM,KAAK,kBAAkB,CAAC,MAAM,EACvD;YACA,qEAAqE;YACrE,OAAO,kBAAkB,CAAC,MAAM,GAAG,kBAAkB,CAAC,MAAM,CAAC;SAC9D;QAED;;WAEG;QACH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE;YACjE,wCAAwC;YACxC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;gBACtB,OAAO,CAAC,CAAC;aACV;YACD,wCAAwC;YACxC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;gBACtB,OAAO,CAAC,CAAC,CAAC;aACX;YAED,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAC7C,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAC7C,iDAAiD;YACjD,IAAI,SAAS,IAAI,SAAS,EAAE;gBAC1B,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;gBACrD,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;gBAErD,IAAI,SAAS,IAAI,SAAS,EAAE;oBAC1B,SAAS;iBACV;qBAAM,IAAI,SAAS,EAAE;oBACpB,OAAO,CAAC,CAAC;iBACV;qBAAM,IAAI,SAAS,EAAE;oBACpB,OAAO,CAAC,CAAC,CAAC;iBACX;gBACD,SAAS;aACV;YACD,gDAAgD;YAChD,IAAI,SAAS,EAAE;gBACb,OAAO,CAAC,CAAC;aACV;YACD,gDAAgD;YAChD,IAAI,SAAS,EAAE;gBACb,OAAO,CAAC,CAAC,CAAC;aACX;YAED,MAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YACzC,MAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YACzC,iDAAiD;YACjD,IAAI,KAAK,IAAI,KAAK,EAAE;gBAClB,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;gBACrD,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;gBAErD,IAAI,SAAS,IAAI,SAAS,EAAE;oBAC1B,SAAS;iBACV;qBAAM,IAAI,SAAS,EAAE;oBACpB,OAAO,CAAC,CAAC;iBACV;qBAAM,IAAI,SAAS,EAAE;oBACpB,OAAO,CAAC,CAAC,CAAC;iBACX;gBAED,SAAS;aACV;YACD,gDAAgD;YAChD,IAAI,KAAK,EAAE;gBACT,OAAO,CAAC,CAAC;aACV;YACD,gDAAgD;YAChD,IAAI,KAAK,EAAE;gBACT,OAAO,CAAC,CAAC,CAAC;aACX;SACF;QAED;;;;;;;;;;;;;;WAcG;QACH,IAAI,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,SAAS,EAAE;YAC/B,OAAO,CAAC,CAAC,CAAC;SACX;aAAM,IAAI,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,SAAS,EAAE;YACtC,OAAO,CAAC,CAAC;SACV;QAED,OAAO,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC;IACzC,CAAC,CAAC;AACJ,CAAC;AACD,WAAW","sourcesContent":["import { PathConfigMap, validatePathConfig } from '@react-navigation/native';\nimport type { InitialState, NavigationState, PartialState } from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\n\nimport { findFocusedRoute } from './findFocusedRoute';\nimport * as forks from './getStateFromPath-forks';\nimport { RouteNode } from '../Route';\nimport { RouterStore } from '../global-state/router-store';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\ntype Options<ParamList extends object> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n\n  // Start Fork\n  allowUrlParamNormalization?: boolean;\n  // End Fork\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  type: 'layout' | 'static' | 'dynamic';\n  isInitial?: boolean;\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n\n  // Start fork\n  expandedRouteNames: string[];\n  userReadableName: string;\n  _route?: RouteNode;\n  isIndex: boolean;\n  hasChildren: boolean;\n  parts: string[];\n  // End fork\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\nexport type ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any> | undefined;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport function getStateFromPath<ParamList extends object>(\n  // Start Fork\n  this: RouterStore | undefined | void,\n  // End Fork\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const expoHelpers = getExpoHelpers(path);\n\n  if (!expoHelpers) {\n    return;\n  }\n\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  const screens = options?.screens;\n\n  let remaining = expoHelpers?.nonstandardPathname\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  const prefix = options?.path?.replace(/^\\//, ''); // Remove extra leading slash\n\n  if (prefix) {\n    // Make sure there is a trailing slash\n    const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;\n\n    // If the path doesn't start with the prefix, it's not a match\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n\n    // Remove the prefix from the path\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment) => {\n        const name = decodeURIComponent(segment);\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(path, routes, initialRoutes, undefined, expoHelpers.hash);\n    }\n\n    return undefined;\n  }\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(key, screens as PathConfigMap<object>, [], initialRoutes, [])\n      )\n    )\n    .sort(getSortConfigsFn(this?.routeInfo?.segments));\n  // End Fork\n\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    if (acc[config.pattern]) {\n      const a = acc[config.pattern].routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        throw new Error(\n          `Found conflicting screens with the same pattern. The pattern '${\n            config.pattern\n          }' resolves to both '${a.join(' > ')}' and '${b.join(\n            ' > '\n          )}'. Patterns must be unique and cannot resolve to more than one screen.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [config.pattern]: config,\n    });\n  }, {});\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.path === '' &&\n        config.routeNames.every(\n          // Make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.path\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        expoHelpers.cleanPath,\n        match.routeNames.map((name) => ({ name })),\n        initialRoutes,\n        configs,\n        expoHelpers.hash\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routes, remainingPath } = matchAgainstConfigs(\n    remaining,\n    // Start Fork\n    // Our forked configs will already have the '$' suffix\n    // configs.map((c) => ({\n    //   ...c,\n    //   // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n    //   regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n    // }))\n    configs\n    // End Fork\n  );\n\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(\n      expoHelpers.cleanPath,\n      routes,\n      initialRoutes,\n      configs,\n      expoHelpers.hash\n    );\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      const matchResult = config.pattern?.split('/').reduce<{\n        pos: number; // Position of the current path param segment in the path (e.g in pattern `a/:b/:c`, `:a` is 0 and `:b` is 1)\n        matchedParams: Record<string, Record<string, string>>; // The extracted params\n      }>(\n        (acc, p, index) => {\n          if (!p.startsWith(':')) {\n            return acc;\n          }\n\n          // Path parameter so increment position for the segment\n          acc.pos += 1;\n\n          // Start Fork\n          // Expo Router's regex is slightly different and may cause an undefined match\n          if (!match![(acc.pos + 1) * 2]) return acc;\n          // End Fork\n\n          const decodedParamSegment = decodeURIComponent(\n            // The param segments appear every second item starting from 2 in the regex match result\n            match![(acc.pos + 1) * 2]\n              // Remove trailing slash\n              .replace(/\\/$/, '')\n          );\n\n          Object.assign(acc.matchedParams, {\n            [p]: Object.assign(acc.matchedParams[p] || {}, {\n              [index]: decodedParamSegment,\n            }),\n          });\n\n          return acc;\n        },\n        { pos: -1, matchedParams: {} }\n      );\n\n      const matchedParams = matchResult.matchedParams || {};\n\n      routes = config.routeNames.map((name) => {\n        const routeConfig = configs.find((c) => {\n          // Check matching name AND pattern in case same screen is used at different levels in config\n          return c.screen === name && config.pattern.startsWith(c.pattern);\n        });\n\n        // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n        const normalizedPath = routeConfig?.path.split('/').filter(Boolean).join('/');\n\n        // Get the number of segments in the initial pattern\n        const numInitialSegments = routeConfig?.pattern\n          // Extract the prefix from the pattern by removing the ending path pattern (e.g pattern=`a/b/c/d` and normalizedPath=`c/d` becomes `a/b`)\n          .replace(new RegExp(`${escape(normalizedPath!)}$`), '')\n          ?.split('/').length;\n\n        const params = normalizedPath\n          ?.split('/')\n          .reduce<Record<string, unknown>>((acc, p, index) => {\n            if (!p.startsWith(':')) {\n              return acc;\n            }\n\n            // Get the real index of the path parameter in the matched path\n            // by offsetting by the number of segments in the initial pattern\n            const offset = numInitialSegments ? numInitialSegments - 1 : 0;\n            const value = matchedParams[p]?.[index + offset];\n\n            if (value) {\n              const key = p.replace(/^:/, '').replace(/\\?$/, '');\n              acc[key] = routeConfig?.parse?.[key] ? routeConfig.parse[key](value) : value;\n            }\n\n            return acc;\n          }, {});\n\n        if (params && Object.keys(params).length) {\n          return { name, params };\n        }\n\n        return { name };\n      });\n\n      // Start Fork\n      // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\n      // However this needs to be a cascading override. e.g /foo/:id/bar/:id. A layout at /foo/_layout will see the first :id\n      // TODO: This behavior is inherited from React Navigation. Do we want this behavior, or should we error?\n      const mergedParams = Object.assign({}, ...routes.map((route) => route.params));\n      if (Object.keys(mergedParams).length > 0) {\n        routes.forEach((route) => {\n          route.params = { ...mergedParams };\n        });\n      }\n      // End Fork\n\n      remainingPath = remainingPath.replace(match[1], '');\n\n      break;\n    }\n  }\n\n  return { routes, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[],\n  parentScreens: string[],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(\n      createConfigItem(\n        screen,\n        routeNames,\n        pattern,\n        config,\n        // Start fork\n        undefined,\n        false\n        // End fork\n      )\n    );\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.parse,\n          // Start fork\n          config.screens ? !!Object.keys(config.screens)?.length : false,\n          config._route\n          // End fork\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  parse?: ParseConfig,\n  // Start fork\n  hasChildren?: boolean,\n  _route?: any\n  // End fork\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  const patternParts: string[] = [];\n  const parts: string[] = [];\n  let isDynamic = false;\n  const isIndex = screen === 'index' || screen.endsWith('/index');\n\n  for (const part of pattern.split('/')) {\n    if (part) {\n      patternParts.push(part);\n\n      // If any part is dynamic, then the route is dynamic\n      isDynamic ||= part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');\n\n      if (!matchGroupName(part)) {\n        parts.push(part);\n      }\n    }\n  }\n\n  pattern = patternParts.join('/');\n\n  if (isIndex) {\n    parts.push('index');\n  }\n\n  const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';\n\n  const regex = pattern\n    ? new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    // Start fork\n    type,\n    parts,\n    expandedRouteNames: routeNames.flatMap((name) => {\n      return name.split('/');\n    }),\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join('/'),\n    hasChildren: !!hasChildren,\n    isIndex,\n    _route,\n    // End fork\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      let sameParents = true;\n      for (let i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        // Start fork\n        // routes: [{ name: initialRoute }, route],\n        routes: [{ name: initialRoute, params: route.params }, route],\n        // End fork\n      };\n    } else {\n      return {\n        routes: [route],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          // Start fork\n          // { name: initialRoute },\n          { name: initialRoute, params: route.params },\n          // End fork\n          { ...route, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ ...route, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  initialRoutes: InitialRouteConfig[],\n  flatConfig?: RouteConfig[],\n  // Start fork\n  hash?: string\n  // End fork\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(initialRoute, route, routes.length === 0);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n  route.path = path;\n\n  const params = parseQueryParams(\n    path,\n    flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined,\n    hash\n  );\n\n  if (params) {\n    // Start fork\n    // route.params = { ...route.params, ...params };\n    forks.mutateRouteParams(route, params);\n    // End fork\n  }\n\n  return state;\n};\n\n// Start fork - this function was replaced\n// const parseQueryParams = (\n//   path: string,\n//   parseConfig?: Record<string, (value: string) => any>\n// ) => {\n//   const query = path.split('?')[1];\n//   const params = queryString.parse(query);\n\n//   if (parseConfig) {\n//     Object.keys(params).forEach((name) => {\n//       if (\n//         Object.hasOwnProperty.call(parseConfig, name) &&\n//         typeof params[name] === 'string'\n//       ) {\n//         params[name] = parseConfig[name](params[name] as string);\n//       }\n//     });\n//   }\n\n//   return Object.keys(params).length ? params : undefined;\n// };\nconst parseQueryParams = forks.parseQueryParams;\n// End fork\n\n// Start Fork\nconst baseUrlCache = new Map<string, RegExp>();\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      const reg = getBaseUrlRegex(baseUrl);\n      return path.replace(/^\\/+/g, '/').replace(reg, '');\n    }\n  }\n  return path;\n}\n\nfunction getBaseUrlRegex(baseUrl: string) {\n  if (baseUrlCache.has(baseUrl)) {\n    return baseUrlCache.get(baseUrl)!;\n  }\n  const regex = new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g');\n  baseUrlCache.set(baseUrl, regex);\n  return regex;\n}\n// End Fork\n\n// Start Fork\nexport function getExpoHelpers(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  const expoURL = getUrlWithReactNavigationConcessions(path, baseUrl);\n\n  if (!expoURL.url) {\n    return;\n  }\n\n  let cleanPath =\n    stripBaseUrl(stripGroupSegmentsFromPath(expoURL.url.pathname), baseUrl) + expoURL.url.search;\n\n  if (!path.startsWith('/')) cleanPath = cleanPath.slice(1);\n\n  return {\n    cleanPath,\n    hash: expoURL.url.hash.slice(1),\n    ...expoURL,\n  };\n}\n// End Fork\n\n// Start Fork\nexport function getUrlWithReactNavigationConcessions(path: string, baseUrl?: string) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      nonstandardPathname: '',\n      inputPathnameWithoutHash: '',\n      url: null,\n    };\n  }\n\n  const pathname = parsed.pathname;\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    nonstandardPathname:\n      stripBaseUrl(pathname, baseUrl).replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    url: parsed,\n  };\n}\n// End Fork\n\n// Start fork\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n// End Fork\n\n// Start Fork\nfunction getSortConfigsFn(previousSegments: string[] = []) {\n  return function sortConfigs(a: RouteConfig, b: RouteConfig): number {\n    // Sort config so that:\n    // - the most exhaustive ones are always at the beginning\n    // - patterns with wildcard are always at the end\n\n    // If 2 patterns are same, move the one with less route names up\n    // This is an error state, so it's only useful for consistent error messages\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n\n    /*\n     * If one of the patterns starts with the other, it is earlier in the config sorting.\n     * However, configs are a mix of route configs and layout configs\n     * e.g There will be a config for `/(group)`, but maybe there isn't a `/(group)/index.tsx`\n     *\n     * This is because you can navigate to a directory and its navigator will determine the route\n     * These routes should be later in the config sorting, as their patterns are very open\n     * and will prevent routes from being matched\n     *\n     * Therefore before we compare segment parts, we force these layout configs later in the sorting\n     *\n     * NOTE(marklawlor): Is this a feature we want? I'm unsure if this is a gimmick or a feature.\n     */\n    if (a.pattern.startsWith(b.pattern) && !b.isIndex) {\n      return -1;\n    }\n\n    if (b.pattern.startsWith(a.pattern) && !a.isIndex) {\n      return 1;\n    }\n\n    /*\n     * Static routes should always be higher than dynamic and layout routes.\n     */\n    if (a.type === 'static' && b.type !== 'static') {\n      return -1;\n    } else if (a.type !== 'static' && b.type === 'static') {\n      return 1;\n    }\n\n    /*\n     * If both are static/dynamic or a layout file, then we check group similarity\n     */\n    const similarToPreviousA = previousSegments.filter((value, index) => {\n      return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    const similarToPreviousB = previousSegments.filter((value, index) => {\n      return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    if (\n      (similarToPreviousA.length > 0 || similarToPreviousB.length > 0) &&\n      similarToPreviousA.length !== similarToPreviousB.length\n    ) {\n      // One matches more than the other, so pick the one that matches more\n      return similarToPreviousB.length - similarToPreviousA.length;\n    }\n\n    /*\n     * If there is not difference in similarity, then each non-group segment is compared against each other\n     */\n    for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {\n      // if b is longer, b get higher priority\n      if (a.parts[i] == null) {\n        return 1;\n      }\n      // if a is longer, a get higher priority\n      if (b.parts[i] == null) {\n        return -1;\n      }\n\n      const aWildCard = a.parts[i].startsWith('*');\n      const bWildCard = b.parts[i].startsWith('*');\n      // if both are wildcard we compare next component\n      if (aWildCard && bWildCard) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aWildCard) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bWildCard) {\n        return -1;\n      }\n\n      const aSlug = a.parts[i].startsWith(':');\n      const bSlug = b.parts[i].startsWith(':');\n      // if both are wildcard we compare next component\n      if (aSlug && bSlug) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aSlug) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bSlug) {\n        return -1;\n      }\n    }\n\n    /*\n     * Both configs are identical in specificity and segments count/type\n     * Try and sort by initial instead.\n     *\n     * TODO: We don't differentiate between the default initialRoute and group specific default routes\n     *\n     * const unstable_settings = {\n     *   \"group\": {\n     *     initialRouteName: \"article\"\n     *  }\n     * }\n     *\n     * \"article\" will be ranked higher because its an initialRoute for a group - even if not your not currently in\n     * that group. The current work around is to ways provide initialRouteName for all groups\n     */\n    if (a.isInitial && !b.isInitial) {\n      return -1;\n    } else if (!a.isInitial && b.isInitial) {\n      return 1;\n    }\n\n    return b.parts.length - a.parts.length;\n  };\n}\n// End fork\n"]}