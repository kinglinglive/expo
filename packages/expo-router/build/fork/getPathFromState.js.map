{"version":3,"file":"getPathFromState.js","sourceRoot":"","sources":["../../src/fork/getPathFromState.ts"],"names":[],"mappings":"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","sourcesContent":["import { PathConfig, PathConfigMap, validatePathConfig } from '@react-navigation/native';\nimport type { NavigationState, PartialState, Route } from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\ntype Options<ParamList extends object> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n\n  // Start fork\n  preserveDynamicRoutes?: boolean;\n  preserveGroups?: boolean;\n  // End fork\n};\n\nexport type State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport function getPathFromState<ParamList extends object>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  return getPathDataFromState(state, options).path;\n}\n\nexport function getPathDataFromState<ParamList extends object>(\n  state: State,\n  { preserveDynamicRoutes, preserveGroups, ...options }: Options<ParamList> = { screens: {} }\n) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = options?.screens\n    ? createNormalizedConfigs(options?.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n  let hash: string | undefined;\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    const focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    const nestedRouteNames: string[] = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        // Start Fork\n        if (route.params['#'] !== undefined) {\n          // route.params is frozen, so we need to clone it\n          const { '#': _hash, ...params } = route.params as Record<string, any>;\n          hash = _hash;\n          // route.params is readonly, so we need to make it a new object\n          // But we cannot change its identity as its used below\n          Object.assign(route, { params });\n        }\n        // End Fork\n\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = Object.fromEntries(\n          // Start fork - better handle array params\n          // Object.entries(route.params).map(([key, value]) => [\n          //   key,\n          //   stringify?.[key] ? stringify[key](value) : String(value),\n          // ])\n          Object.entries(route.params!).map(([key, value]) => [\n            key,\n            stringify?.[key]\n              ? stringify[key](value)\n              : Array.isArray(value)\n                ? value.map(String)\n                : String(value),\n          ])\n          // End Fork\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            // Valid characters according to\n            // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n            return String(value).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, (char) =>\n              encodeURIComponent(char)\n            );\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      // Start Fork\n      // const query = queryString.stringify(focusedParams, { sort: false });\n      const { '#': hash, ...focusedParamsWithoutHash } = focusedParams;\n      const query = queryString.stringify(focusedParamsWithoutHash, { sort: false });\n      // End Fork\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  // Include the root path if specified\n  if (options?.path) {\n    path = joinPaths(options.path, path);\n  }\n\n  if (hash) {\n    allParams['#'] = hash;\n    path += `#${hash}`;\n  }\n\n  path = appendBaseUrl(path);\n\n  return { path, params: allParams };\n}\n\nexport function decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (key === 'params' && typeof value === 'object') {\n        parsed[key] = decodeParams(value);\n      } else if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n\nconst getParamName = (pattern: string) => pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\n"]}